<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Atom Feed -->
    <link type="application/atom+xml" rel="alternate" href="https://www.eidel.io/feed.xml" title="Oliver Eidel" />

    <!-- SEO -->
    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Writing a HTTP API Client in Elixir for the Noun Project | Oliver Eidel</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Writing a HTTP API Client in Elixir for the Noun Project" />
<meta name="author" content="Oliver Eidel" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Doing some HTTP requests is usually one of the first things I do when I’m learning a new language (apart from comparing its performance in highly artificial benchmarks and checking whether it scales)." />
<meta property="og:description" content="Doing some HTTP requests is usually one of the first things I do when I’m learning a new language (apart from comparing its performance in highly artificial benchmarks and checking whether it scales)." />
<link rel="canonical" href="https://www.eidel.io/2017/07/13/http-api-client-elixir-noun-project/" />
<meta property="og:url" content="https://www.eidel.io/2017/07/13/http-api-client-elixir-noun-project/" />
<meta property="og:site_name" content="Oliver Eidel" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-07-13T11:00:00+02:00" />
<script type="application/ld+json">
{"url":"https://www.eidel.io/2017/07/13/http-api-client-elixir-noun-project/","headline":"Writing a HTTP API Client in Elixir for the Noun Project","dateModified":"2017-07-13T11:00:00+02:00","datePublished":"2017-07-13T11:00:00+02:00","description":"Doing some HTTP requests is usually one of the first things I do when I’m learning a new language (apart from comparing its performance in highly artificial benchmarks and checking whether it scales).","author":{"@type":"Person","name":"Oliver Eidel"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.eidel.io/2017/07/13/http-api-client-elixir-noun-project/"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <!-- CSS and Fonts -->
    <link href="/css/site.css" rel="stylesheet" type="text/css" />
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,600;0,700;0,800;1,300;1,400;1,600;1,700;1,800&family=Roboto+Mono&display=swap" rel="stylesheet">

    <!-- JS -->
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70715341-1"></script>
<script>
 window.dataLayer = window.dataLayer || [];
 function gtag(){dataLayer.push(arguments);}
 gtag('js', new Date());
 gtag('config', 'UA-70715341-1', {anonymize_ip: true });
</script>

    <script type='text/javascript'>
 window.smartlook||(function(d) {
   var o=smartlook=function(){ o.api.push(arguments)},h=d.getElementsByTagName('head')[0];
   var c=d.createElement('script');o.api=new Array();c.async=true;c.type='text/javascript';
   c.charset='utf-8';c.src='https://rec.smartlook.com/recorder.js';h.appendChild(c);
 })(document);
 smartlook('init', 'c9c5a6df7647642a0876dbf981a16ef0c8351236');
</script>

    
  </head>

  <body class="text-gray-200 bg-image">
    <div id="main-overlay" class="overlay-frosted mx-auto max-w-2xl sm:mt-8 sm:px-5 py-3 sm:rounded shadow-xl">
      <nav class="flex flex-col sm:flex-row items-center mx-3 sm:py-2">
  <div class="sm:w-20">
    <a class="px-2 sm:px-0 py-1 flex flex-row sm:flex-col text-gray-400 hover:text-white text-sm uppercase tracking-widest leading-tight" href="/">
      <div>Oliver</div>
      <div class="ml-2 sm:ml-0">Eidel</div>
    </a>
  </div>
  <ul class="mt-1 sm:mt-0 flex-1 flex flex-row flex-wrap justify-center text-gray-200 text-sm uppercase font-medium leading-tight tracking-wider">
    <a class="px-2 py-1 hover:text-white" href="/"><li>Home</li></a>
    <a class="px-2 py-1 hover:text-white" href="/about"><li>About</li></a>
    <a class="px-2 py-1 hover:text-white" href="/talks"><li>Talks</li></a>
    <a class="px-2 py-1 hover:text-white" href="/reading"><li>Reading</li></a>
    <a class="px-2 py-1 hover:text-white" href="/publications"><li>Publications</li></a>
  </ul>
  <div class="mt-2 sm:mt-0 sm:w-20 flex sm:justify-end text-gray-400">
    <a class="p-1 sm:p-0 hover:text-white" href="https://github.com/olieidel/" rel="nofollow" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="24" height="24" viewBox="0 0 24 24" class="fill-current w-5 h-5">
  <path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z"/>
</svg></a>
    <a class="ml-1 p-1 sm:p-0 hover:text-white" href="https://twitter.com/olieidel" rel="nofollow" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="24" height="24" viewBox="0 0 24 24" class="fill-current w-5 h-5">
  <path d="M22.46,6C21.69,6.35 20.86,6.58 20,6.69C20.88,6.16 21.56,5.32 21.88,4.31C21.05,4.81 20.13,5.16 19.16,5.36C18.37,4.5 17.26,4 16,4C13.65,4 11.73,5.92 11.73,8.29C11.73,8.63 11.77,8.96 11.84,9.27C8.28,9.09 5.11,7.38 3,4.79C2.63,5.42 2.42,6.16 2.42,6.94C2.42,8.43 3.17,9.75 4.33,10.5C3.62,10.5 2.96,10.3 2.38,10C2.38,10 2.38,10 2.38,10.03C2.38,12.11 3.86,13.85 5.82,14.24C5.46,14.34 5.08,14.39 4.69,14.39C4.42,14.39 4.15,14.36 3.89,14.31C4.43,16 6,17.26 7.89,17.29C6.43,18.45 4.58,19.13 2.56,19.13C2.22,19.13 1.88,19.11 1.54,19.07C3.44,20.29 5.7,21 8.12,21C16,21 20.33,14.46 20.33,8.79C20.33,8.6 20.33,8.42 20.32,8.23C21.16,7.63 21.88,6.87 22.46,6Z"/>
</svg></a>
    <a class="ml-1 p-1 sm:p-0 hover:text-white" href="https://www.linkedin.com/in/oliver-eidel/" rel="nofollow" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="24" height="24" viewBox="0 0 24 24" class="fill-current w-5 h-5">
  <path d="M19 3A2 2 0 0 1 21 5V19A2 2 0 0 1 19 21H5A2 2 0 0 1 3 19V5A2 2 0 0 1 5 3H19M18.5 18.5V13.2A3.26 3.26 0 0 0 15.24 9.94C14.39 9.94 13.4 10.46 12.92 11.24V10.13H10.13V18.5H12.92V13.57C12.92 12.8 13.54 12.17 14.31 12.17A1.4 1.4 0 0 1 15.71 13.57V18.5H18.5M6.88 8.56A1.68 1.68 0 0 0 8.56 6.88C8.56 5.95 7.81 5.19 6.88 5.19A1.69 1.69 0 0 0 5.19 6.88C5.19 7.81 5.95 8.56 6.88 8.56M8.27 18.5V10.13H5.5V18.5H8.27Z"/>
</svg></a>
  </div>
</nav>

      <main>
        <article class="mt-4 mx-3">
  <div class="py-6 bg-gray-700 border border-gray-500 rounded shadow-lg hover:shadow-2xl cursor-default">
    <div class="text-xs text-center text-gray-400 uppercase leading-tight">13 Jul 2017</div>
    <h1 class="text-3xl text-center text-white font-semibold tracking-wide leading-tight">Writing a HTTP API Client in Elixir for the Noun Project</h1>
  </div>

  <article class="post mt-6">
    <p>Doing some HTTP requests is usually one of the first things I do when
I’m learning a new language (apart from comparing its performance in
highly artificial benchmarks and checking whether it scales).</p>

<p>Of all the “up-and-coming languages with great concurrency” Elixir is
one of the most promising. While the community is awesome, the library
ecosystem is still, um, growing. As an alchemist with slightly
uncommon use cases one has to rise to the challenge of concocting ones
own little libraries.</p>

<p>Today, let’s write a HTTP client for
the <a href="https://thenounproject.com">Noun Project</a>. There already are wrappers available
for <a href="https://github.com/rosshettel/the-noun-project">Node.js</a>, <a href="https://github.com/onassar/PHP-TheNounProject">PHP</a>
and <a href="https://github.com/TailorBrands/noun-project-api">Ruby</a> - but not Elixir (yet!).</p>

<p>I’ll guide you through the process of writing an Elixir library by
trying out, exploring and refactoring. If you’re an intermediate or
beginning Elixir Alchemist, this is for you.</p>

<p>If you’re just interested in the library itself (I advise against
shortcuts, young alchemist!)
the <a href="https://github.com/olieidel/noun_projex">noun_projex code</a> is up
on <a href="https://github.com/olieidel/noun_projex">GitHub</a> you can find
the <a href="https://hex.pm/packages/noun_projex">published package</a>
on <a href="https://hex.pm/packages/noun_projex">Hex.pm</a>.</p>

<h2 id="getting-started">Getting started</h2>

<p>Head over to the <a href="https://thenounproject.com">Noun Project</a>, register an account and
create an API project on
their <a href="https://thenounproject.com/developers/apps/">developer’s page</a>. The free
“Playground” pricing tier should be more than enough for our purposes
as we only need it for testing our client.</p>

<h3 id="setting-up-the-project">Setting up the project</h3>

<p>Let’s start a new project with mix:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mix new noun_projex
<span class="nb">cd </span>noun_projex
</code></pre></div></div>

<h3 id="getting-dependencies">Getting dependencies</h3>

<p>Next, we need libraries for HTTP requests and JSON parsing. The upside
of Elixir’s small ecosystem is that you hardly lose time contemplating
which library to use as there almost always is one clear choice. We
shall choose <a href="https://hex.pm/packages/httpoison">HTTPoison</a> for the former
and <a href="https://hex.pm/packages/poison">Poison</a> for the latter. Further, we will
need <a href="https://hex.pm/packages/oauther">oauther</a> for some serious OAuthing Voodoo.</p>

<p>Let’s edit our <code class="highlighter-rouge">deps</code> function in <code class="highlighter-rouge">mix.exs</code> and insert those
aforementioned dependencies:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defp</span> <span class="n">deps</span> <span class="k">do</span>
  <span class="p">[{</span><span class="ss">:httpoison</span><span class="p">,</span> <span class="s2">"~&gt; 0.12"</span><span class="p">},</span>
   <span class="p">{</span><span class="ss">:poison</span><span class="p">,</span> <span class="s2">"~&gt; 3.1"</span><span class="p">},</span>
   <span class="p">{</span><span class="ss">:oauther</span><span class="p">,</span> <span class="s2">"~&gt; 1.1"</span><span class="p">}]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Note that after Elixir 1.4 we no longer need to add HTTPoison to our
<code class="highlighter-rouge">applications</code> function as it is automatically inferred (see
the <a href="https://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/">Elixir 1.4 release announcement</a>, section
“Application inference”).</p>

<p>Finally, fetch the dependencies in your shell:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mix deps.get
</code></pre></div></div>

<p>We’re ready for some serious HTTP API Client coding!</p>

<h2 id="accessing-endpoints">Accessing Endpoints</h2>

<p>For every new project I code, I like to just whip up the <em>naive
approach</em> first, in the way of “how would I do it if I wouldn’t have
to consider architecture, best practices, security, code style, error
handling and what people think of me?”. In my experience, this is a
great way of combating “coder’s block” - sitting in front one’s
keyboard and not coding anything because you’ve got “analysis
paralysis”, turning things over in your head without coming to any
sort of conclusion.</p>

<p>It’s also a great way to write really ugly code.</p>

<h3 id="naive-approach">Naive approach</h3>

<p>Let’s take a quick look at the <a href="http://api.thenounproject.com/documentation.html">API docs</a>. How
about trying to query that first endpoint <code class="highlighter-rouge">GET /collection/(int:id)</code>?</p>

<p>Quick note: The way we write functions shall be <code class="highlighter-rouge">function_name/arity</code>
where arity means the number of arguments the function takes. It’s the
Erlang / Elixir way of writing things.</p>

<p>Having briefly looked at
the <a href="https://github.com/edgurgel/httpoison">HTTPoison GitHub Readme</a>, our <code class="highlighter-rouge">get_collection/1</code> should
look something like this in <code class="highlighter-rouge">lib/noun_projex.ex</code>. Add some
documentation for good measure:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">NounProjex</span> <span class="k">do</span>
  <span class="c1"># Documentation in Elixir may include Markdown</span>
  <span class="nv">@moduledoc</span> <span class="sd">"""
  [Noun Project](https://thenounproject.com) API Client in Elixir.
  """</span>

  <span class="nv">@doc</span> <span class="sd">"""
  Returns a single collection by id (int).
  """</span>
  <span class="k">def</span> <span class="n">get_collection</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">do</span>
    <span class="c1"># We're using string interpolation here.</span>
    <span class="c1"># #{id} means it inserts the value of id</span>
    <span class="n">url</span> <span class="o">=</span> <span class="s2">"http://api.thenounproject.com/collection/</span><span class="si">#{</span><span class="n">id</span><span class="si">}</span><span class="s2">"</span>
    <span class="n">response</span> <span class="o">=</span>
      <span class="no">HTTPoison</span><span class="o">.</span><span class="n">get!</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="no">Poison</span><span class="o">.</span><span class="n">decode!</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>So what’s the idea here? We construct our request URL by passing in
the id parameter as seen in the API documentation, make a HTTP GET
request and parse the resulting JSON response with Poison.</p>

<p>And… it fails with a HTTP 400 Bad Request error. Our approach was
very naive indeed. Of course we have to use our Noun Project API
credentials somehow.</p>

<h3 id="oauth-1-voodoo">OAuth 1 Voodoo</h3>

<p>Now, the Noun Project uses OAuth 1.0a which is rather old and there’s
all sorts of Voodoo going on there. I lost quite some time trying to
get this part working so I’ll only briefly outline the plot and give
you the solution to save you precious time:</p>

<ol>
  <li>Search for an Elixir OAuth 1 library.</li>
  <li>Try to understand it just enough to make it work.</li>
  <li>Hack around in IEx. Doesn’t work.</li>
  <li>Read up on the OAuth 1 spec and don’t understand anything.</li>
  <li>Go back to 2. about 25 times.</li>
  <li>It works. Done.</li>
</ol>

<p>This is how our naive <code class="highlighter-rouge">get_collection/1</code> should look now with some
Voodoo sprinkled in:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">get_collection</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">consumer_key</span> <span class="o">=</span> <span class="s2">"YOUR_CONSUMER_KEY"</span>
  <span class="n">consumer_secret</span> <span class="o">=</span> <span class="s2">"YOUR_CONSUMER_SECRET"</span>
  <span class="n">method</span> <span class="o">=</span> <span class="s2">"get"</span>

  <span class="n">url</span> <span class="o">=</span> <span class="s2">"http://api.thenounproject.com/collection/</span><span class="si">#{</span><span class="n">id</span><span class="si">}</span><span class="s2">"</span>

  <span class="n">credentials</span> <span class="o">=</span> <span class="no">OAuther</span><span class="o">.</span><span class="n">credentials</span><span class="p">(</span><span class="ss">consumer_key:</span> <span class="n">consumer_key</span><span class="p">,</span>
                                    <span class="ss">consumer_secret:</span> <span class="n">consumer_secret</span><span class="p">)</span>
  <span class="n">params</span> <span class="o">=</span> <span class="no">OAuther</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="p">[],</span> <span class="n">credentials</span><span class="p">)</span>

  <span class="c1"># we deconstruct the output here and don't care about the</span>
  <span class="c1"># request params</span>
  <span class="p">{</span><span class="n">header</span><span class="p">,</span> <span class="n">_req_params</span><span class="p">}</span> <span class="o">=</span> <span class="no">OAuther</span><span class="o">.</span><span class="n">header</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

  <span class="c1"># HTTPoison expect a lists of headers as second argument.</span>
  <span class="c1"># We only have one, therefore we pass a list</span>
  <span class="c1"># with header as only item</span>
  <span class="n">response</span> <span class="o">=</span> <span class="no">HTTPoison</span><span class="o">.</span><span class="n">get!</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="p">[</span><span class="n">header</span><span class="p">])</span>
  <span class="no">Poison</span><span class="o">.</span><span class="n">decode!</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Alright! We should be getting some sort of a reply with HTTP status
200 now. How about we look at the next Noun Project API endpoint and
continue?</p>

<p>Nope. The naive coding approach is good in the way that it gets us
going quickly but we should look out for opportunities for refactoring
(and not procrastinate). Here, our <code class="highlighter-rouge">get_collection/1</code> function is
suboptimal because it actually has two tasks: Requesting the API auth
header and calling the API endpoint. Also, we would have to copy-paste
those code blocks every time we would write a function for another API
endpoint.</p>

<p>To keep our own sanity, it’s probably best to split those up into
separate functions. How about we extract the procedure of requesting
auth header first?</p>

<h3 id="oauth-1-voodoo-refactored">OAuth 1 Voodoo refactored</h3>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">NounProjex</span> <span class="k">do</span>
  <span class="nv">@consumer_key</span> <span class="o">=</span> <span class="s2">"YOUR_CONSUMER_KEY"</span>
  <span class="nv">@consumer_secret</span> <span class="o">=</span> <span class="s2">"YOUR_CONSUMER_SECRET"</span>

  <span class="c1"># ...</span>

  <span class="nv">@doc</span> <span class="sd">"""
  Construct OAuth 1 header with some serious Voodoo involved.
  """</span>
  <span class="k">defp</span> <span class="n">construct_oauth_header</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">credentials</span> <span class="o">=</span> <span class="no">OAuther</span><span class="o">.</span><span class="n">credentials</span><span class="p">(</span>
                    <span class="ss">consumer_key:</span> <span class="nv">@consumer_key</span><span class="p">,</span>
                    <span class="ss">consumer_secret:</span> <span class="nv">@consumer_secret</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="no">OAuther</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="p">[],</span> <span class="n">credentials</span><span class="p">)</span>
    <span class="p">{</span><span class="n">header</span><span class="p">,</span> <span class="n">_req_params</span><span class="p">}</span> <span class="o">=</span> <span class="no">OAuther</span><span class="o">.</span><span class="n">header</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="n">header</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>In case you haven’t noticed yet, the OAuth 1 auth request procedure
actually depends on the exact URL (with parameters) you request. Just
thought I’d mention that as it cost me two hours of clueless debugging.</p>

<p>We also extract our <code class="highlighter-rouge">consumer_key</code> and <code class="highlighter-rouge">consumer_secret</code> and set them
as <a href="https://elixir-lang.org/getting-started/module-attributes.html">module attributes</a> at the top of our
module. Later on, we will follow best practices and put them in a more
appropriate place but for now this is good enough.</p>

<p>The content of the <code class="highlighter-rouge">construct_oauth_header/2</code> function is pretty much
identical to what we saw before. We only return the <code class="highlighter-rouge">header</code> as we’re
not interested in the rest.</p>

<p>However, another less obvious opportunity for refactoring can be seen
now: The pattern of function calls in our function is quite linear -
we’re always calling one function, then passing on that result to the
next function and so on. It might be worth a try to refactor that into
a <a href="http://openmymind.net/Elixirs-With-Statement/">with statement</a>, right?</p>

<h3 id="oauth-1-voodoo-refactored-into-with-statement">OAuth 1 Voodoo refactored into with statement</h3>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defp</span> <span class="n">construct_oauth_header</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># credentials have been renamed to creds</span>
  <span class="n">with</span> <span class="n">creds</span> <span class="o">&lt;-</span> <span class="no">OAuther</span><span class="o">.</span><span class="n">credentials</span><span class="p">(</span>
                  <span class="ss">consumer_key:</span> <span class="nv">@consumer_key</span><span class="p">,</span>
                  <span class="ss">consumer_secret:</span> <span class="nv">@consumer_secret</span><span class="p">),</span>
       <span class="n">params</span> <span class="o">&lt;-</span> <span class="no">OAuther</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="p">[],</span> <span class="n">creds</span><span class="p">),</span>
       <span class="p">{</span><span class="n">header</span><span class="p">,</span> <span class="n">_req_params</span><span class="p">}</span> <span class="o">&lt;-</span> <span class="no">OAuther</span><span class="o">.</span><span class="n">header</span><span class="p">(</span><span class="n">params</span><span class="p">),</span>
    <span class="k">do</span><span class="p">:</span> <span class="n">header</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Ah. Nice and sweet. We’re basically doing the same stuff as before but
this time our code looks more concise and we could later on add an
<code class="highlighter-rouge">else</code> block to our <code class="highlighter-rouge">with</code> statement to handle all function
errors in one place.</p>

<p>Our <code class="highlighter-rouge">get_collection/1</code> now becomes:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">get_collection</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">url</span> <span class="o">=</span> <span class="s2">"http://api.thenounproject.com/collection/</span><span class="si">#{</span><span class="n">id</span><span class="si">}</span><span class="s2">"</span>
  <span class="n">header</span> <span class="o">=</span> <span class="n">construct_oauth_header</span><span class="p">(</span><span class="s2">"get"</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>
  <span class="no">HTTPoison</span><span class="o">.</span><span class="n">get!</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="p">[</span><span class="n">header</span><span class="p">])</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Looks good so far. In Elixir, functions ending with a bang <code class="highlighter-rouge">!</code> usually
throw exceptions when an error occurs. We would have to catch those
when they happen - however, that’s not the Elixir way of doing things.</p>

<h3 id="better-error-handling">Better error handling</h3>

<p>We rather use HTTPoison’s <code class="highlighter-rouge">get</code> function without a bang instead and
handle some errors via a <code class="highlighter-rouge">case</code> statement:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">get_collection</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">url</span> <span class="o">=</span> <span class="s2">"http://api.thenounproject.com/collection/</span><span class="si">#{</span><span class="n">id</span><span class="si">}</span><span class="s2">"</span>
  <span class="n">header</span> <span class="o">=</span> <span class="n">construct_oauth_header</span><span class="p">(</span><span class="s2">"get"</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>

  <span class="k">case</span> <span class="no">HTTPoison</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">headers</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">%</span><span class="no">HTTPoison</span><span class="o">.</span><span class="no">Response</span><span class="p">{</span><span class="ss">status_code:</span> <span class="mi">200</span><span class="p">,</span> <span class="ss">body:</span> <span class="n">body</span><span class="p">}}</span> <span class="o">-&gt;</span>
      <span class="c1"># HTTP status 200 (OK) and we have a body</span>
      <span class="k">case</span> <span class="no">Poison</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">body</span><span class="p">)</span> <span class="k">do</span>
        <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">decoded</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">decoded</span><span class="p">}</span>
        <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="n">error</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="n">error</span><span class="p">}</span>
      <span class="k">end</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">%</span><span class="no">HTTPoison</span><span class="o">.</span><span class="no">Response</span><span class="p">{</span><span class="ss">status_code:</span> <span class="n">status_code</span><span class="p">}}</span> <span class="o">-&gt;</span>
      <span class="c1"># any other HTTP status code</span>
      <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="n">status_code</span><span class="p">}</span>
    <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="n">error</span><span class="p">}</span> <span class="o">-&gt;</span>
      <span class="c1"># some error while making request</span>
      <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="n">error</span><span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Notice how I added the <a href="https://hexdocs.pm/elixir/master/guards.html">guard</a> <code class="highlighter-rouge">is_integer/1</code>? As we’re
expecting <code class="highlighter-rouge">id</code> to only be an integer, we might as well enforce this.</p>

<p>We also change the return signature of our function to a tuple of
<code class="highlighter-rouge">{status, payload}</code> so a caller of our function could do similar error
handling. In this example, we react to all non-200 HTTP status codes
the same way but of course we could pattern match any HTTP code
specifically to react to erroneous responses in a more fine-grained
manner.</p>

<p>The rest is just pattern matching on HTTPoison’s and Poison’s return
values. Remember, Poison was the JSON decoding library and when we get
a good (status 200) response, we attempt to decode the body from JSON
to an Elixir map.</p>

<p>Great! Now, onto the next API endpoint.</p>

<p>Um, not so fast. When coding up the function for the next endpoint, we
would have to copy-paste that whole <code class="highlighter-rouge">case HTTPoison.get(url, headers)</code>
block all over again, right?</p>

<h3 id="extracting-http-requests">Extracting HTTP requests</h3>

<p>Another nice opportunity for refactoring. Let’s extract the HTTP
request part into a private function:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defp</span> <span class="n">do_request</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">headers</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">case</span> <span class="no">HTTPoison</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">headers</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">%</span><span class="no">HTTPoison</span><span class="o">.</span><span class="no">Response</span><span class="p">{</span><span class="ss">status_code:</span> <span class="mi">200</span><span class="p">,</span> <span class="ss">body:</span> <span class="n">body</span><span class="p">}}</span> <span class="o">-&gt;</span>
      <span class="k">case</span> <span class="no">Poison</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">body</span><span class="p">)</span> <span class="k">do</span>
        <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">decoded</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">decoded</span><span class="p">}</span>
        <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="n">error</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="n">error</span><span class="p">}</span>
      <span class="k">end</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">%</span><span class="no">HTTPoison</span><span class="o">.</span><span class="no">Response</span><span class="p">{</span><span class="ss">status_code:</span> <span class="n">status_code</span><span class="p">}}</span> <span class="o">-&gt;</span>
      <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="n">status_code</span><span class="p">}</span>
    <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="n">error</span><span class="p">}</span> <span class="o">-&gt;</span>
      <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="n">error</span><span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>That’s just copy-paste. Should be fine for now. Let’s have a look at our updated <code class="highlighter-rouge">get_collection/1</code>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">get_collection</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">url</span> <span class="o">=</span> <span class="s2">"http://api.thenounproject.com/collection/</span><span class="si">#{</span><span class="n">id</span><span class="si">}</span><span class="s2">"</span>
  <span class="n">header</span> <span class="o">=</span> <span class="n">construct_oauth_header</span><span class="p">(</span><span class="s2">"get"</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>

  <span class="n">do_request</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="p">[</span><span class="n">header</span><span class="p">])</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Nice and concise. Onwards to the next API endpoint! Looking at
the <a href="http://api.thenounproject.com/documentation.html">Noun Project API docs</a> again, that would
be <code class="highlighter-rouge">GET /collection/(int: id)/icons</code>. Let’s skip that for the moment
and go on to the next (third) one, which is <code class="highlighter-rouge">GET /collection/(slug)</code>.</p>

<p>Ugh! Your inner API designer moans. It’s the same endpoint which we
already have coded but this time it accepts a different type of input
(<code class="highlighter-rouge">slug</code> is a string, instead of <code class="highlighter-rouge">id</code> which was an integer
earlier). Luckily, Elixir’s <a href="https://hexdocs.pm/elixir/master/guards.html">guard</a> has our back here
(subtle pun intended).</p>

<h3 id="same-endpoints-different-type">Same Endpoints, different type</h3>

<p>We just copy-paste our prior function but change the guard (and
docstring, of course):</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">@doc</span> <span class="sd">"""
Returns a single collection by slug (string).
"""</span>
<span class="k">def</span> <span class="n">get_collection</span><span class="p">(</span><span class="n">slug</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_binary</span><span class="p">(</span><span class="n">slug</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">url</span> <span class="o">=</span> <span class="s2">"http://api.thenounproject.com/collection/</span><span class="si">#{</span><span class="n">slug</span><span class="si">}</span><span class="s2">"</span>
  <span class="n">header</span> <span class="o">=</span> <span class="n">construct_oauth_header</span><span class="p">(</span><span class="s2">"get"</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>

  <span class="n">do_request</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="p">[</span><span class="n">header</span><span class="p">])</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Note that we use the guard <code class="highlighter-rouge">is_binary/1</code> here as strings are binaries
in Elixir. The rest remains the same.</p>

<h3 id="endpoint-with-parameters">Endpoint with parameters</h3>

<p>Onwards to the endpoint we skipped just now (the second): <code class="highlighter-rouge">GET
/collection/(int: id)/icons</code>.</p>

<p>Let’s code it:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">@doc</span> <span class="sd">"""
Returns a list of icons associated with a collection by id (int).
"""</span>
<span class="k">def</span> <span class="n">get_collection_icons</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">page</span><span class="p">)</span>
      <span class="ow">when</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">do</span>
      <span class="c1"># another guard</span>

  <span class="n">base_url</span> <span class="o">=</span> <span class="s2">"http://api.thenounproject.com/collection/</span><span class="si">#{</span><span class="n">id</span><span class="si">}</span><span class="s2">/icons"</span>
  <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="ss">limit:</span> <span class="n">limit</span><span class="p">,</span>  <span class="c1"># 1.</span>
            <span class="ss">offset:</span> <span class="n">offset</span><span class="p">,</span>
            <span class="ss">page:</span><span class="n">page</span><span class="p">]</span>
  <span class="n">query</span> <span class="o">=</span> <span class="no">URI</span><span class="o">.</span><span class="n">encode_query</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>  <span class="c1"># 2.</span>
  <span class="n">url</span> <span class="o">=</span> <span class="n">base_url</span> <span class="o">&lt;&gt;</span> <span class="s2">"/?"</span> <span class="o">&lt;&gt;</span> <span class="n">query</span>  <span class="c1"># 3.</span>
  <span class="n">header</span> <span class="o">=</span> <span class="n">construct_oauth_header</span><span class="p">(</span><span class="s2">"get"</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>

  <span class="n">do_request</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="p">[</span><span class="n">header</span><span class="p">])</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now we have a bit of a new situation as we have to somehow pass
additional query parameters to the url. This is what’s going on here:</p>

<ol>
  <li>First, assign <code class="highlighter-rouge">params</code> to be a keyword list of our parameters.</li>
  <li>Then, encode that into a URI query e.g. <code class="highlighter-rouge">limit=123&amp;offset=3&amp;page=4</code></li>
  <li>Concatenate that with the <code class="highlighter-rouge">base_url</code> and don’t forget a slash and
question mark in between making our URL look like
<code class="highlighter-rouge">http://api.foo.com/?limit=123&amp;offset=3&amp;page=4</code></li>
</ol>

<p>Don’t forget that you have to pass the URL which includes the
parameters to your OAuth function as those parameters are of course
part of the URL - no use passing the <code class="highlighter-rouge">base_url</code> to the OAuth function!
I hope I saved you another hour of debugging obscure auth bugs there,
I certainly spent that time debugging…</p>

<p>Now, this works but it becomes noticeable that we are still repeating
ourselves. We always have to specify the <code class="highlighter-rouge">url</code> which we are requesting
and manually interpolate the request parameters into it. Now that we
have explored the API endpoints further and know that we sometimes
also have to add request parameters we might as well incorporate all
of that into a private function.</p>

<h3 id="extracting-url-construction">Extracting URL construction</h3>

<p>First, some thoughts. How about a function call signature like this:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">construct_url</span><span class="p">(</span><span class="s2">"collections"</span><span class="p">)</span>
<span class="s2">"http://api.thenounproject.com/collections"</span>

<span class="n">iex</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">123</span>
<span class="mi">123</span>

<span class="n">iex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">construct_url</span><span class="p">([</span><span class="s2">"collection"</span><span class="p">,</span> <span class="n">id</span><span class="p">])</span>
<span class="s2">"http://api.thenounproject.com/collection/123"</span>

<span class="n">iex</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="ss">limit:</span> <span class="mi">50</span><span class="p">,</span> <span class="ss">offset:</span> <span class="mi">10</span><span class="p">,</span> <span class="ss">page:</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="ss">limit:</span> <span class="mi">50</span><span class="p">,</span> <span class="ss">offset:</span> <span class="mi">10</span><span class="p">,</span> <span class="ss">page:</span> <span class="mi">3</span><span class="p">]</span>

<span class="n">iex</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">construct_url</span><span class="p">([</span><span class="s2">"collection"</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="s2">"icons"</span><span class="p">],</span> <span class="n">params</span><span class="p">)</span>
<span class="s2">"http://api.thenounproject.com/collection/123/
 icons/?limit=50&amp;offset=10&amp;page=3"</span>
</code></pre></div></div>

<p>Looks okay? To implement that, we have to handle three input cases:</p>

<ol>
  <li>One parameter of type string</li>
  <li>One parameter of type list</li>
  <li>Two parameters of type list</li>
</ol>

<p>Elixir’s pattern matching really shines here:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">NounProjex</span> <span class="k">do</span>
  <span class="nv">@base_url</span> <span class="s2">"http://api.thenounproject.com"</span>

  <span class="c1"># ...</span>

  <span class="k">defp</span> <span class="n">construct_url</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_binary</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="k">do</span>
    <span class="nv">@base_url</span> <span class="o">&lt;&gt;</span> <span class="s2">"/"</span> <span class="o">&lt;&gt;</span> <span class="n">dir</span>
  <span class="k">end</span>
  <span class="k">defp</span> <span class="n">construct_url</span><span class="p">(</span><span class="n">dirs</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_list</span><span class="p">(</span><span class="n">dirs</span><span class="p">)</span> <span class="k">do</span>
    <span class="nv">@base_url</span> <span class="o">&lt;&gt;</span> <span class="s2">"/"</span> <span class="o">&lt;&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="s2">"/"</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="k">defp</span> <span class="n">construct_url</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span> <span class="k">do</span>
    <span class="c1"># notice the awesomeness!</span>
    <span class="n">construct_url</span><span class="p">(</span><span class="n">dirs</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="s2">"/?"</span> <span class="o">&lt;&gt;</span> <span class="no">URI</span><span class="o">.</span><span class="n">encode_query</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>What sort of wizardry have we done? For one parameter, it’s simple:</p>

<ul>
  <li>If it’s a string, simply concatenate it to <code class="highlighter-rouge">@base_url</code></li>
  <li>If it’s a list, join the list’s contents with a slash and
concatenate that to <code class="highlighter-rouge">@base_url</code></li>
</ul>

<p>By the way, we extracted the <code class="highlighter-rouge">base_url</code> to be a module attribute.</p>

<p>Our <code class="highlighter-rouge">construct_url/2</code> is even more interesting: It calls
<code class="highlighter-rouge">construct_url/1</code> with the first parameter <code class="highlighter-rouge">dirs</code> and just adds the
encoded URI parameters to the end of the string. That means that we
can actually call it by passing either a string or a list to <code class="highlighter-rouge">dirs</code> as
both are handled appropriately by delegating to the one-parameter
function <code class="highlighter-rouge">construct_url/1</code>!</p>

<p>Of course we could have handled this task with an external library but
where’s the fun in that?</p>

<p>Our updated <code class="highlighter-rouge">get_collection_icons/4</code> now looks like this:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">get_collection_icons</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">page</span><span class="p">)</span>
      <span class="ow">when</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">do</span>

  <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="ss">limit:</span> <span class="n">limit</span><span class="p">,</span>
            <span class="ss">offset:</span> <span class="n">offset</span><span class="p">,</span>
            <span class="ss">page:</span> <span class="n">page</span><span class="p">]</span>

  <span class="n">url</span> <span class="o">=</span> <span class="n">construct_url</span><span class="p">([</span><span class="s2">"collection"</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="s2">"icons"</span><span class="p">],</span> <span class="n">params</span><span class="p">)</span>
  <span class="n">header</span> <span class="o">=</span> <span class="n">construct_oauth_header</span><span class="p">(</span><span class="s2">"get"</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>

  <span class="n">do_request</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="p">[</span><span class="n">header</span><span class="p">])</span>
<span class="k">end</span>
</code></pre></div></div>

<p>It looks yet cleaner again!</p>

<p>By the way, the API docs state that when no <code class="highlighter-rouge">limit</code> is provided,
<code class="highlighter-rouge">limit</code> is assumed to be 50. And if <code class="highlighter-rouge">page</code> is provided, <code class="highlighter-rouge">offset</code> is
ignored. So that’s tricky with our function parameter order: If we
only want to pass in a value for <code class="highlighter-rouge">page</code>, what do we do with <code class="highlighter-rouge">offset</code>?
Pass <code class="highlighter-rouge">0</code>? That doesn’t seem very clean.</p>

<p>Wouldn’t it be better if we were to filter the parameters beforehand
so that only “allowed” parameters could be passed? This would also
allow us to describe our API query parameters as data, namely, as a
list.</p>

<h3 id="parameter-filtering">Parameter filtering</h3>

<p>Our new <code class="highlighter-rouge">get_collection_icons/2</code> should look something like this. We
circumvent the problem of “parameter ordering” by passing all
parameters as one variable <code class="highlighter-rouge">params</code> (a keyword list) and filtering
them appropriately with <code class="highlighter-rouge">filter_params/2</code> which we still have to write:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">get_collection_icons</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
      <span class="ow">when</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">do</span>

  <span class="n">params</span> <span class="o">=</span> <span class="n">filter_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span>
             <span class="p">[</span><span class="ss">:limit</span><span class="p">,</span> <span class="ss">:offset</span><span class="p">,</span> <span class="ss">:page</span><span class="p">])</span>

  <span class="n">url</span> <span class="o">=</span> <span class="n">construct_url</span><span class="p">([</span><span class="s2">"collection"</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="s2">"icons"</span><span class="p">],</span> <span class="n">params</span><span class="p">)</span>
  <span class="n">header</span> <span class="o">=</span> <span class="n">construct_oauth_header</span><span class="p">(</span><span class="s2">"get"</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>

  <span class="n">do_request</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="p">[</span><span class="n">header</span><span class="p">])</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Looks better yet. We are basically describing which query parameters
are allowed and discarding those which aren’t. The implementation of
<code class="highlighter-rouge">filter_params/2</code> is trivial:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defp</span> <span class="n">filter_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">allowed_params</span><span class="p">)</span> <span class="k">do</span>
  <span class="no">Enum</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="k">fn</span> <span class="p">{</span><span class="n">key</span><span class="p">,</span> <span class="n">_value</span><span class="p">}</span> <span class="o">-&gt;</span>
    <span class="n">key</span> <span class="ow">in</span> <span class="n">allowed_params</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>By deconstructing each entry of <code class="highlighter-rouge">params</code> to <code class="highlighter-rouge">{key, _value}</code> we can
iterate only over the keys and ignore the values for now. The
expression <code class="highlighter-rouge">key in allowed_params</code> returns true if the our current
parameter key is allowed and false otherwise. Using that in
<code class="highlighter-rouge">Enum.filter/2</code> lets us simply discard all non-allowed params with
their values. Nice!</p>

<p>There’s actually a built-in abstraction for that: <code class="highlighter-rouge">Keyword.take/2</code>. So
we could go on and yet further simplify our implementation:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defp</span> <span class="n">filter_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">allowed_params</span><span class="p">)</span> <span class="k">do</span>
  <span class="no">Keyword</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">allowed_params</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We could also call <code class="highlighter-rouge">Keyword.take/2</code> directly instead of calling it via
<code class="highlighter-rouge">filter_params/2</code> - that’s a matter of style and personal preference,
I guess. You decide!</p>

<h3 id="packing-more-into-do_request">Packing more into do_request</h3>

<p>Now there still are some low-hanging fruit. We still are repeatedly
calling <code class="highlighter-rouge">construct_url</code> and <code class="highlighter-rouge">construct_oauth_header/2</code> in every API
request function. I suggest we integrate those into <code class="highlighter-rouge">do_request</code> as we
will have to construct the url and auth headers for every request
anyway. Due to <code class="highlighter-rouge">construct_oauth_header/2</code> having to know the request
method (GET / POST), we will have to pass it to <code class="highlighter-rouge">do_request</code>.</p>

<p>From the other side, it should look something like this:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">do_request</span><span class="p">(</span><span class="ss">:get</span><span class="p">,</span> <span class="p">[</span><span class="s2">"collection"</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
                    <span class="ss">limit:</span> <span class="mi">20</span><span class="p">,</span> <span class="ss">offset:</span> <span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<p>Note that Elixir passes the last two arguments (<code class="highlighter-rouge">limit: 20</code> and
<code class="highlighter-rouge">offset: 10</code>) actually as one parameter (a keyword list) to the
function. If they weren’t the last parameters (e.g., somewhere in the
middle) or we would want to write it in a more verbose manner, we
could write:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">do_request</span><span class="p">(</span><span class="ss">:get</span><span class="p">,</span> <span class="p">[</span><span class="s2">"collection"</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
                    <span class="p">[</span><span class="ss">limit:</span> <span class="mi">20</span><span class="p">,</span> <span class="ss">offset:</span> <span class="mi">10</span><span class="p">])</span>
</code></pre></div></div>

<p>Or even more verbose, using the internal representation of keyword
lists:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">do_request</span><span class="p">(</span><span class="ss">:get</span><span class="p">,</span> <span class="p">[</span><span class="s2">"collection"</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
                    <span class="p">[{</span><span class="ss">:limit</span><span class="p">,</span> <span class="mi">20</span><span class="p">},</span> <span class="p">{</span><span class="ss">:offset</span><span class="p">,</span> <span class="mi">10</span><span class="p">}])</span>
</code></pre></div></div>

<p>Good to know. I didn’t understand this myself for quite some
time. Anyway, let’s not get distracted and commence the implementation
of <code class="highlighter-rouge">do_request/3</code>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="n">do_request</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># note the new variable `method` in the function</span>
  <span class="c1"># we are passing `path` instead of `url`</span>
  <span class="c1"># we are not passing `headers` anymore</span>
  <span class="c1"># `params` is another new variable</span>

  <span class="n">url</span> <span class="o">=</span> <span class="n">construct_url</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

  <span class="c1"># note the to_string(method) call below</span>
  <span class="n">headers</span> <span class="o">=</span> <span class="p">[</span><span class="n">construct_oauth_header</span><span class="p">(</span><span class="n">to_string</span><span class="p">(</span><span class="n">method</span><span class="p">),</span> <span class="n">url</span><span class="p">)]</span>

  <span class="k">case</span> <span class="no">HTTPoison</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">headers</span><span class="p">)</span> <span class="k">do</span>
    <span class="c1"># the same as in the last iteration</span>
    <span class="c1"># omitted for brevity</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Looking good! I decided that passing the request method as an atom
(<code class="highlighter-rouge">:get</code> instead of <code class="highlighter-rouge">"get"</code>) looks cleaner - but I’ll let you
decide. Anyway, now we have to convert it to a string for the OAuth
Voodoo library as seen above.</p>

<p>We also construct the headers. Then we execute the request as seen
before already.</p>

<h3 id="implementing-the-updated-functions">Implementing the updated functions</h3>

<p>Going back to our last API endpoint it should now look like this:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">get_collection_icons</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
      <span class="ow">when</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">do</span>

  <span class="n">params</span> <span class="o">=</span> <span class="n">filter_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span>
             <span class="p">[</span><span class="ss">:limit</span><span class="p">,</span> <span class="ss">:offset</span><span class="p">,</span> <span class="ss">:page</span><span class="p">])</span>
  <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"collection"</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="s2">"icons"</span><span class="p">]</span>

  <span class="n">do_request</span><span class="p">(</span><span class="ss">:get</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Awesome! How much cleaner can it get?</p>

<p>What about our API endpoints which don’t take any query parameters?
How about creating <code class="highlighter-rouge">do_request/2</code> which doesn’t take any <code class="highlighter-rouge">params</code> but
delegates the call to <code class="highlighter-rouge">do_request/3</code> with an empty list for <code class="highlighter-rouge">params</code>?
Sounds tricky but actually it’s a one-liner:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">do_request</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">do_request</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="p">[])</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We simply delegate the call to <code class="highlighter-rouge">do_request/3</code> with an empty list as <code class="highlighter-rouge">params</code>.</p>

<p>Let’s take a look how the two other endpoints which we implemented
earlier look now in their final iteration:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">get_collection</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">do_request</span><span class="p">(</span><span class="ss">:get</span><span class="p">,</span> <span class="p">[</span><span class="s2">"collection"</span><span class="p">,</span> <span class="n">id</span><span class="p">])</span>
<span class="k">end</span>

<span class="k">def</span> <span class="n">get_collection</span><span class="p">(</span><span class="n">slug</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_binary</span><span class="p">(</span><span class="n">slug</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">do_request</span><span class="p">(</span><span class="ss">:get</span><span class="p">,</span> <span class="p">[</span><span class="s2">"collection"</span><span class="p">,</span> <span class="n">slug</span><span class="p">])</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Your Inner Functional Programming Aficionado (IFPA) should be overjoyed.</p>

<h3 id="metaprogramming">Metaprogramming</h3>

<p>Can we go any further? Yes! Having to write a new function for every
API endpoint seems like a repetitive thing to do. We could describe
all API endpoints as one big data structure and create the function at
compile time with macros.</p>

<p>I must confess that I stopped there. My library was already more than
<em>good enough</em> (and clean enough!) and I do tend to get lost
over-engineering stuff so I have to stop optimizing at some stage.</p>

<p>I could however imagine the data structure to look somewhat like this:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">api_endpoints</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">{</span><span class="ss">:get_collection</span><span class="p">,</span> <span class="p">[</span><span class="s2">"collection"</span><span class="p">,</span> <span class="ss">:id</span><span class="p">],</span> <span class="p">[</span><span class="ss">id:</span> <span class="ss">:int</span><span class="p">],</span> <span class="p">[]},</span>
  <span class="p">{</span><span class="ss">:get_collection</span><span class="p">,</span> <span class="p">[</span><span class="s2">"collection"</span><span class="p">,</span> <span class="ss">:id</span><span class="p">],</span> <span class="p">[</span><span class="ss">id:</span> <span class="ss">:string</span><span class="p">],</span> <span class="p">[]},</span>
  <span class="p">{</span><span class="ss">:get_collection_icons</span><span class="p">,</span>
    <span class="p">[</span><span class="s2">"collection"</span><span class="p">,</span> <span class="ss">:id</span><span class="p">,</span> <span class="s2">"icons"</span><span class="p">],</span>
    <span class="p">[</span><span class="ss">id:</span> <span class="ss">:int</span><span class="p">],</span>
    <span class="p">[</span><span class="ss">:limit</span><span class="p">,</span> <span class="ss">:offset</span><span class="p">,</span> <span class="ss">:page</span><span class="p">]}</span>
<span class="p">]</span>
</code></pre></div></div>

<p>So you would have to describe each API endpoint as data. Each tuple consists of:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">function_name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">param_types</span><span class="p">,</span> <span class="n">query_params</span><span class="p">}</span>
</code></pre></div></div>

<p>And then your macro would have to read each tuple and create a
function accordingly. Well, that’s at least how I would approach it
(in its first iteration…). It does sound kind of over-engineered but
very fun.</p>

<p>If you’re further interested in Elixir’s macros you should definitely
check out Chris McCord’s
book <a href="https://pragprog.com/book/cmelixir/metaprogramming-elixir">Metaprogramming Elixir</a> after which
implementing the above while creating a flying saucer and a perpetuum
mobile should be no problem for you.</p>

<h2 id="further-improvements">Further improvements</h2>

<p>What else is there to do? Earlier, we procrastinated saving our API
keys in a safe way (you remember that, right?) so we should take care
of that now. Here is how it looks currently:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">NounProjex</span> <span class="k">do</span>
  <span class="nv">@consumer_key</span> <span class="o">=</span> <span class="s2">"YOUR_CONSUMER_KEY"</span>
  <span class="nv">@consumer_secret</span> <span class="o">=</span> <span class="s2">"YOUR_CONSUMER_SECRET"</span>

  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This is probably not a good idea. Why?</p>

<ol>
  <li>When you commit it to version control (e.g. git), your keys are
baked in even if you delete the file later on. It will be tedious
to delete that specific file later and modify your version control
history (if you remember to do that at all).</li>
  <li>As soon as the library leaves your computer (e.g. when publishing
to GitHub, sending it to a colleague, deploying to server) your API
keys will most likely be seen by a third party.</li>
</ol>

<p>How do we mitigate this issue? In
the <a href="http://www.phoenixframework.org">Phoenix Framework</a> this problem is quite
elegantly solved in config files with the suffix <code class="highlighter-rouge">.secret</code>,
e.g. <code class="highlighter-rouge">prod.secret.exs</code> in the <code class="highlighter-rouge">config</code> directory of your project.</p>

<p>That sounds like a great idea. Let’s steal it.</p>

<h3 id="setting-up-the-config">Setting up the config</h3>

<p>Create the file <code class="highlighter-rouge">dev.secret.exs</code> in the <code class="highlighter-rouge">config</code> directory:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">use</span> <span class="no">Mix</span><span class="o">.</span><span class="no">Config</span>

<span class="n">config</span> <span class="ss">:noun_projex</span><span class="p">,</span>
  <span class="ss">api_key:</span> <span class="s2">"YOUR_CONSUMER_KEY"</span><span class="p">,</span>
  <span class="ss">api_secret:</span> <span class="s2">"YOUR_CONSUMER_SECRET"</span>
</code></pre></div></div>

<p>We then have to make sure it gets loaded, of course only in <code class="highlighter-rouge">dev</code> and
<code class="highlighter-rouge">test</code> for now. Open up <code class="highlighter-rouge">config.exs</code>, also in the <code class="highlighter-rouge">config</code> directory
and key this in:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">use</span> <span class="no">Mix</span><span class="o">.</span><span class="no">Config</span>

<span class="n">dev_secret_path</span> <span class="o">=</span> <span class="no">Path</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="s2">"config/dev.secret.exs"</span><span class="p">)</span>

<span class="k">if</span> <span class="no">Mix</span><span class="o">.</span><span class="n">env</span> <span class="ow">in</span> <span class="p">[</span><span class="ss">:dev</span><span class="p">,</span> <span class="ss">:test</span><span class="p">]</span> <span class="k">do</span>
  <span class="k">if</span> <span class="no">File</span><span class="o">.</span><span class="n">exists?</span><span class="p">(</span><span class="n">dev_secret_path</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">import_config</span> <span class="s2">"dev.secret.exs"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>So we only import our <code class="highlighter-rouge">dev.secret.exs</code> file if it exists. We could
omit the <code class="highlighter-rouge">File.exists?</code> check but then our application would crash
when the file is missing.</p>

<p>We of course have to modify our module attributes in
<code class="highlighter-rouge">lib/noun_projex.ex</code> accordingly:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">NounProjex</span> <span class="k">do</span>
  <span class="nv">@consumer_key</span> <span class="no">Application</span><span class="o">.</span><span class="n">get_env</span><span class="p">(</span><span class="ss">:noun_projex</span><span class="p">,</span> <span class="ss">:api_key</span><span class="p">)</span>
  <span class="nv">@consumer_secret</span> <span class="no">Application</span><span class="o">.</span><span class="n">get_env</span><span class="p">(</span><span class="ss">:noun_projex</span><span class="p">,</span> <span class="ss">:api_secret</span><span class="p">)</span>

  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>There’s not much to explain here - <code class="highlighter-rouge">Application.get_env</code> is simply a
way to read variables which you have configured in your <code class="highlighter-rouge">config</code>
directory.</p>

<p>We are done, right? Nope. Notice what’s missing?</p>

<p>We still have to add <code class="highlighter-rouge">dev.secret.exs</code> to the <code class="highlighter-rouge">.gitignore</code> in the root
project directory otherwise our whole effort would have been futile:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code># The directory Mix will write compiled artifacts to.
/_build

# ...
# lots more auto-generated stuff from mix
# ...

# API keys
config/dev.secret.exs  # &lt;-- this is new
</code></pre></div></div>

<p>Woopah! Nice and safe. Now you can <code class="highlighter-rouge">git commit</code> safely and your API keys
steer clear of your version control history.</p>

<p>What else could there possibly be to do?</p>

<h3 id="testing">Testing</h3>

<p>If we had been following “Test-driven development” (TDD, not Tower
Defense Defense as I would have read it a year ago) we would have
written our tests before we had written our library.</p>

<p>While TDD can be a good tool to have, personally, when I’m not
entirely sure how my functions (or API) are going to look like, I tend
to use the “naive approach” and write my code in an exploratory way
first. In those situations, TDD tends to get in my way. It’s like when
someone is sitting behind you and constantly asking you “what are you
doing? what are you doing?” and you have no clue but have to reply
somehow. Very annoying.</p>

<p>That’s not to say that we don’t need tests! Now that our API is
stable, we should write some. Let’s open up <code class="highlighter-rouge">tests/noun_projex_test.exs</code>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">NounProjexTest</span> <span class="k">do</span>
  <span class="c1"># set async to true as our tests don't depend</span>
  <span class="c1"># on each other, saving us time</span>
  <span class="kn">use</span> <span class="no">ExUnit</span><span class="o">.</span><span class="no">Case</span><span class="p">,</span> <span class="ss">async:</span> <span class="no">true</span>

  <span class="c1"># test our documentation, at the moment there's</span>
  <span class="c1"># nothing to test there (yet!)</span>
  <span class="n">doctest</span> <span class="no">NounProjex</span>

  <span class="c1"># Our tests will go here</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This is how it should look like for starters. Let’s write tests for
the three API endpoints we coded functions for:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Set some fixtures as module attributes</span>
<span class="c1"># Fixtures are basically "testing constants"</span>
<span class="nv">@collection_id</span> <span class="mi">26590</span>
<span class="nv">@collection_slug</span> <span class="s2">"bike"</span>
<span class="nv">@params</span> <span class="p">[</span><span class="ss">limit:</span> <span class="mi">20</span><span class="p">,</span> <span class="ss">offset:</span> <span class="mi">0</span><span class="p">]</span>

<span class="n">test</span> <span class="s2">"get collection by id"</span> <span class="k">do</span>
  <span class="n">assert</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">_result</span><span class="p">}</span> <span class="o">=</span> <span class="no">NounProjex</span><span class="o">.</span><span class="n">get_collection</span><span class="p">(</span><span class="nv">@collection_id</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">test</span> <span class="s2">"get collection by slug"</span> <span class="k">do</span>
  <span class="n">assert</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">_result</span><span class="p">}</span> <span class="o">=</span> <span class="no">NounProjex</span><span class="o">.</span><span class="n">get_collection</span><span class="p">(</span><span class="nv">@collection_slug</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">test</span> <span class="s2">"get collection icons by id"</span> <span class="k">do</span>
  <span class="n">assert</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">_result</span><span class="p">}</span> <span class="o">=</span>
    <span class="no">NounProjex</span><span class="o">.</span><span class="n">get_collection_icons</span><span class="p">(</span><span class="nv">@collection_id</span><span class="p">,</span> <span class="nv">@params</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Run <code class="highlighter-rouge">mix test</code> in your shell and you should see three unremarkable
green dots (I do hope so).</p>

<p>Our test suite is very minimalistic. We are only expecting an <code class="highlighter-rouge">{:ok,
_result}</code> tuple which means that any test will pass as long as the
HTTP response code is 200. Of course this isn’t very thorough and you
should set up some more detailed fixtures. For example, you could call
the API with our test parameters, note down the return values and save
those as an expected result. This is of course assuming that the Noun
Project API always returns the same values over time.</p>

<p>But for now, it’s good enough. Testing for HTTP 200 allows us to catch
authentification problems, wrongly constructed URLs, malformed
parameters and probably a few more things. Not that bad at all.</p>

<h2 id="summary">Summary</h2>

<p>Phew! What a journey! We went from naively hacking in <code class="highlighter-rouge">HTTPoison.get!</code>
requests to quite a polished API via approximately one thousand
refactorings. We added proper configuration support and some tests to
round things off.</p>

<p>For me, this was a great learning experience. I hope that I could save
you some time and you learnt a lot along the way, too!</p>

<p>The complete <a href="https://github.com/olieidel/noun_projex">noun_projex code</a> is up
on <a href="https://github.com/olieidel/noun_projex">GitHub</a>. It’s also <a href="https://hex.pm/packages/noun_projex">published</a>
to <a href="https://hex.pm/packages/noun_projex">Hex.pm</a>.</p>

<p>Thanks for corrections goes out to <a href="https://github.com/ggpasqualino">@ggpasqualino</a>, <a href="https://disqus.com/by/thorstendeinert/">@thorstendeinert</a>
and <a href="https://github.com/schaary">@schaary</a>.</p>


  </article>
</article>
<section class="mt-8 mx-3 px-3 py-4 border border-gray-500 bg-gray-700 rounded shadow-lg hover:shadow-2xl">
  <h3 class="text-xl text-white font-semibold tracking-wide leading-tight">Thanks for Reading!</h3>

  <p class="mt-2 text-sm text-gray-400 leading-snug tracking-wide">I write semi-regularly about programming, medicine and, of course, various self-experiments. If you'd like me to send you an e-mail once I've posted something new, feel free to subscribe below.</p>

  <form class="mt-4 flex justify-center" action="https://eidel.us20.list-manage.com/subscribe/post?u=e57e3fd638942b559576d7a14&amp;id=07ef9210b4" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" target="_blank" novalidate>
    <input class="appearance-none w-64 px-3 py-2 bg-gray-200 text-gray-800 placeholder-gray-500 border-t border-b border-l border-gray-500 rounded-l tracking-wide leading-tight shadow-lg" type="email" value="" name="EMAIL" class="required" placeholder="your@email.com" id="mce-EMAIL">
    <input class="appearance-none px-3 py-2 bg-gray-600 hover:bg-gray-800 border-t border-r border-b border-gray-500 rounded-r text-sm tracking-wide leading-tight uppercase shadow-lg" type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button">
    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_e57e3fd638942b559576d7a14_07ef9210b4" tabindex="-1" value=""></div>
  </form>
</section>


      </main>
      <footer class="mt-8 text-xs text-gray-500 text-center" id="funny-quote">An App a Day keeps the Doctor away.</footer>

<script type="text/javascript">
 $(document).ready(function() {
   // We'll respect non-js people by having the first quote in the
   // HTML DOM at the beginning
   var funnyQuotes = ["An App a Day keeps the Doctor away.","Better a doctor working as a programmer than a programmer working as a doctor.","You can teach yourself to code but you can't teach yourself medicine.","A Quality Management System won't save you from writing crappy software."];
   var randomFunnyQuote = funnyQuotes[Math.floor(Math.random() * funnyQuotes.length)];
   var footerEl = document.getElementById('funny-quote');
   footerEl.innerHTML = randomFunnyQuote;
 });
</script>

    </div>
    <div class="mt-4 mb-8 text-xs text-white text-center" id="look-behind-container">
  <a id="look-behind" href="#">What's behind this?</a>
</div>
<div class="mx-auto h-screen flex items-center justify-center" style="display:none" id="show-content-container">
  <section class="max-w-lg text-white text-center leading-tight">
    <h3 class="text-lg font-semibold tracking-wide uppercase">Image Credit</h3>
    <p class="text-xs mt-2">Photo by <a class="underline" href="https://unsplash.com/@snaps_by_clark?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank">Clark Van Der Beken</a> on <a class="underline" href="https://unsplash.com/@snaps_by_clark?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank">Unsplash</a>.</p>
    <p class="mt-4 text-xs">Got it, Unsplash is cool!</p>
    <a class="text-xs underline" id="show-content" href="#">Let's go back to Oliver's Blog.</a>
</div>

<script type="text/javascript">
 $(document).ready(function() {
   $('#look-behind').on('click', function() {
     $('#look-behind-container').hide();
     $('#main-overlay').fadeToggle(500);
     $('#show-content-container').show();
   });

   $('#show-content').on('click', function() {
     $('#show-content-container').hide();
     $('#main-overlay').fadeToggle(500);
     $('#look-behind-container').show();
   });
 });
</script>

  </body>
</html>
